---
layout: post
title:  "CTF学习笔记"
date:   2021-11-06 17:02:00 +0800
categories: CTF study
tags: CTF学习笔记
img: https://gitee.com/fourv/imagebad/raw/master/OXz1xu^AyMV5.jpg
---



# 快速入门Misc



​	**Misc**，虽然是脑洞题，可是在多年出题的演变下来，最终还是有了流派或套路，熟知它们有益于快速解简单题。此外，Misc部分套路的终点是其他CTF方向，对这些套路有所了解，将有助于选手选择自己所向往的进阶方向。

​	本篇将总结所有Misc基础套路，非常简单，非常有趣，人人都可以学得会。



***

## 0x01 编码

​	简单来说，把一段随便什么文本，**通过各种规则变成另一段文本**，最后还能通过某种方法变回去，这就叫编码。是不是很通俗易懂？

​	Misc**最低难度**的题目都是编码题，而混合题目也往往会顺手整点编码要素进去，而CTF其他方向也往往会需要各种编码的知识，因此学好编码不仅仅是学好Misc的第一步，也是学好CTF的第一步。

### 1.1 Base系列

​	**Base系列**相当于CTF界的HelloWorld了，以这道题作为入门CTF的第一题，似乎已经成为了传统艺能。据说辨别一场比赛是不是新手赛的一大关键点就是：这场比赛有没有Base系列的题目。

​	Base系列编码，简单来说，就是把一段文字或者其他什么东西，每X个字节一组，按照某种规则分割成Y个字节，然后按照对应的表单换算成特定的字母。它有助于把一些不可见字符（比如ascii码很小的那些）转化为ABCDE12345。

#### 1.1.1 Base64

​	Base64是**HelloWorld里的HelloWorld**，是Base系列里**最常见、最常用、最有实际运用价值**的编码，在CTF的世界里也算是**最简单**的。

​	Base64码的标志是文本末尾**的=，或者==**，这是Base系列的补足符号。如果由一段疑似乱码的文本出现了这种标志，且是**大小写混合还包括数字**，那么几乎可以肯定就是Base64。不过要注意的是，Base64编码过的文本，末尾是**可能没有=**的。

​	例子：

```
SGVsbG9Xb3JsZA==
```

* [Base64解决地址](https://base64.us/#)

#### 1.1.2 Base32

​	Base32比Base64罕见

​	Base32码也存在与Base64类似的=或==标志，但是特点是**不存在小写英文字母，也不存在8和9**。如果由一段疑似乱码的文本出现了这种标志，且是大写英文字母混数字，那么几乎可以肯定就是Base32。同上，Base32编码过的文本，末尾是可能没有=的。

​	例子：

```
JBSWY3DPK5XXE3A=
```

* [Base32解决地址](https://www.qqxiuzi.cn/bianma/base.php)

#### 1.1.3 Base16

​	Base16是Base御三家里最罕见的编码了

​	它**只包括0~9和大写的A~F，也不存在例如=的标志**，因此隐藏在无意义文本中的Base16几乎无法被发现（当然出题人不会做这种险恶的事情），而且也很容易和普通的十六进制数混淆。不过，值得注意的是，Base16码往往比较长。

​	例子：

```
48656C6C6F576F726C64
```

* [Base16解决地址](https://www.qqxiuzi.cn/bianma/base.php?type=16)

### 1.2 其他编码

#### 1.2.1 ASCII编码

​	Ascii码应该是各位选手最熟悉的非Base编码了，基本Ascii从0~127，而拓展Ascii则不在讨论范围内，毕竟用Ascii编码特异文字（比如中文）属于睿智行为。Ascii码**往往会以\u作为开头**，但是也可能不带\u。

​	例子：

```
\u0048\u0065\u006c\u006c\u006f\u0057\u006f\u0072\u006c\u0064
```

* [ASCII解决地址](https://www.sojson.com/ascii.html)

#### 1.2.2 Unicode

​	Unicode是一种值得尊敬的**国际化编码**，用来作为各个国家/地区编码转化的中间接口。不过在题目里，这种编码属于白送分

​	Unicode**往往以&#开头**，然后跟着作为编号的数字，结尾可能带有;也可能不带。

​	例子：

```
&#102; &#108; &#97; &#103;
```

* [Unicode解决地址](http://tool.chinaz.com/tools/unicode.aspx)

#### 1.2.3 URL编码

​	Url编码是**和Web息息相关**的编码，是一种浏览器用来打包表单输入的格式，学好Url编码（虽然这东西简单到要死）有助于以后进军Web方向，但鉴于本篇是Misc快速入门教程，因此仅分析它的格式和翻译方式。

​	Url编码**以%开头**，后面跟两个十六进制字母——是不是很眼熟？没错，这两个十六进制字母就是编码前的文本的Ascii码。

​	例子：

```
%48 %65 %6c %6c %6f %57 %6f %72 %6c %64
```

* [URL解决地址](http://www.jsons.cn/urlencode/)

#### 1.2.4 XX编码

​	XX编码其实差不多是换皮Base64，和Base64有着几乎相同的原理，主要的区别是换了个对应表。此外，它的末尾补足符号是+而非=，而且可能出现连续三个+。

​	例子：

```
8G4JgP4xLPr7gN+++
```

* [XX编码解决地址](http://web.chacuo.net/charsetxxencode)



### 1.3 进制转化

#### 1.3.1 16进制

#### 1.3.2 8进制

#### 1.3.3 2进制

#### 1.3.4 其他进制

​	

​	此类题目主要的难点在于能否想到是进制转化，以及能否辨别各种偏门进制（比如7进制、9进制、11进制），并且意识到最后转化完毕的结果是否要作为Ascii码再转化一次。

​	

* [进制转化解决地址](https://tool.oschina.net/hexconvert)



***



## 0x02 隐写

​	信息，尤其是flag，不一定会简单直白地告诉你，而很可能隐藏在什么地方，等你自己用各种手段去发掘，这种**藏信息**的行为，就叫隐写。不过隐写现在基本上逐渐变成了单独的题目——直接给选手藏了flag的文件，选手只需要把flag提取出来就行。

### 2.1 基于文本

#### 2.1.1 010 Editor

​	010 Editor是一种**二进制分析工具**，能够以二进制方式打开任意文件。下载，安装，破解，对文件右键选择010打开即可。左侧的窗口是文件的基本数据，两字节十六进制数为一组，而右侧则是十六进制数对应Ascii的字符。

​	对于最简单的情况，只需要在右侧下滑，并寻找是否有flag相关的字段即可。而对于较为复杂的情况，则需要借助上方栏目的**加减异或等操作**，才能显示出flag，不过这种情况极其少见，而且往往会有提示。因此如果直接寻找找不到，那就当做不是这种类型然后放弃就好。

### 2.2 基于图像

​	把flag隐藏到图像中，才是隐写**最常见**的格式！从简单到最难，图像隐写才是隐写界的主流，也是绝对不可忽视的类别。

#### 2.2.1 大小隐写

​	大小隐写是一种较为常见，却**很容易被选手忽视**的隐写方式，解决大小隐写最难的环节，是辨别出它。

​	通过二进制方式（比如010 Editor修改）强行修改一张图的大小标志，可以使得一张本来很大的图片只显示较小的一块，从而隐藏其他部分。而在获得了被缩小的图片之后，要做的事情很简单：把图片大小改回去——或者改得更大。

#### 2.2.2 LSB隐写

​	LSB隐写是最为常见的图片隐写，没有之一。如果碰上一张可能隐藏信息的图片，就按LSB来试一试吧。

​	LSB的意思是**最低有效位**，在图片隐写里，往往指**颜色的最低一位**。它的基本形式是把某一颜色通道的最低位进行修改，使得图片发生了极其微小，人眼无法辨别的变化，而进阶形式则可能是修改了其他位或多个位。这修改很可能就是直接把flag写上去了，所以选手的目标就是把写上去的东西提取出来。

#### 2.2.3 多图隐写

​	多图隐写大多数很好分辨，因为题目会给你**两张**很像的图——其他隐写可没这种待遇。但是也有少数非常劲爆的题目，是三张或更多图，或单图多通道作多图隐写，那这些情况对于新选手而言显然有点超纲。因此本条目仅讨论双图情况。

​	多图隐写往往是基于两张图进行的**异或操作**而解密的，但也**可能是相加操作或相减操作**，类型多样。不过好在上文提到的Stegsolve自带应对多图隐写的模式，能够便捷地对两张图进行上述的这几种操作，进而获取隐藏信息。



##  文件杂项

​	其实这才是**真正的Misc**吧？

​	文件杂项主要考察对文件的，更为底层的了解，包括但不限于**修复，提取，破解**等操作，算是基础里较为硬核但不至于太硬核的题型。

### 4.1 文件头

​	文件头往往指文件以二进制打开情况下的**最前面几个字节**，也可以再指该格式下后面跟着的一串储存了固定格式的字节。

​	被上面这句话绕晕了？那我们来个简单版的。

​	用010 Editor打开文件，看到右边一些的能显示字母的窗口了没？看到最开始的几个字母了没？那就是文件头，Over。

#### 4.1.1 类型辨别

​	普通人辨别文件类型，绝大多数都是根据后缀名。但众所周知**后缀名可以被修改**，因此所见或许并非真实。顺带一提，显示后缀名的方法是打开文件点上方的查看栏目，然后勾上文件拓展名。

​	辨别文件真实类型需要使用010 Editor，右键以010打开文件，然后你可以通过右侧窗口最开始的几个字母，检查到它到底是什么文件。然后就可以把后缀名调整成对应的正确后缀，再进行之后的操作了。

#### 4.1.2 文件头补充

​	既然文件头才是文件格式的关键，那题目自然可以对文件头做手脚，比如拿出一个很可能含有flag的关键文件，然后干脆把表示文件格式的那几个字节抹掉！这时候就需要根据其他特征来推断具体文件类型，最后补上合适的文件头，最后正常打开文件。

​	一旦考到就**全凭感觉和经验**，属于非常意识流的题目，联系其他比较靠前的字节来解决吧。顺带一提，这种题目往往会对.zip格式，.jpg格式或.png格式下手。

#### 4.1.3 伪加密破解

​	除了最开始的几个字节的文件头有决定格式的重要意义之外，此后跟着的一串字节也往往有重要意义，对于.zip而言尤其如此，因为只需要**稍作修改，就能让一个普通的.zip压缩文件被大多数压缩软件识别为加密压缩包**，从而无法打开，这就是伪加密。

​	因为是修改文件头而导致的假装加密，因此**输入任何密码都是无效的**。为了破解伪加密，需要对.zip文件头的更多字节有所了解，从而意识到到底是哪些部分遭到了篡改，再加以修复即可。

​	或者，**WinRar**自带的修复功能可以自动破解伪加密，这实在是太令人遗憾了（

#### 4.1.4 二维码修复

​	二维码修复是一种玄学行为，而扫不出来的二维码是玄学中的玄学。对于初级二维码修复，需要注意的是左上右上左下三个**定位角是否完整，以及黑白是否反色**即可。



### 4.2 反编译

​	.exe文件和.elf文件之类的c系语言的产物暂且不论，但对于.jar文件和.apk文件这种java系语言的产物，反编译它们并检查它们的源码是**十分轻松**的，因此不少简单反编译都被归类到Misc当中。

#### 4.2.1 Jar

​	有手就行。

* 下载地址：https://github.com/java-decompiler/jd-gui/releases

#### 4.2.2 Apk

​	同上。

* 下载地址：https://github.com/skylot/jadx/releases/tag/v1.1.0

